<html>
<head> 
    <meta charset="utf-8" />
        <title>Test OFF loader</title>
        <style>
            #container {
                background: #000;
                width: 800px;
                height: 600px;
            }
        </style>
</head>


<body>
    <input type="file" name="inputfile" id="inputfile"> 
    <button>Get JSON data</button>
</body>

<!-- External Libraries -->
<script src="../build/three.js"></script>
<script src="js/controls/OrbitControls.js"></script>

<script type="text/javascript">

    var camera = new THREE.PerspectiveCamera(75,window.innerWidth / window.innerHeight,0.1,10000);
    var scene = new THREE.Scene();
    
    container = document.createElement( 'div' );
	document.body.appendChild( container );

    var ambientLight = new THREE.AmbientLight( 0xcccccc, 0.4 );
    scene.add( ambientLight );
    var pointLight = new THREE.PointLight( 0xffffff, 0.8 );
    camera.add( pointLight );
    scene.add(camera);

    renderer = new THREE.WebGLRenderer();
    renderer.setPixelRatio( window.devicePixelRatio );
    renderer.setSize( window.innerWidth, window.innerHeight );
    container.appendChild( renderer.domElement );

    controls = new THREE.OrbitControls( camera, renderer.domElement );    
    
    // var box = new THREE.BoxGeometry( 600, 600, 600 );
    // var material = new THREE.MeshBasicMaterial( {color: 0x00ff00} );
    // var cube = new THREE.Mesh( box, material );
    // scene.add( cube );

    controls.update();
    console.log(scene);

    animate();
    /*  parser rules
        1. if see #, skip to next line
        2. first line, OFF
        3. second line, num_vertices num_faces num_edges
        4. vertices line, x y z
        5. faces line, dim v1 v2 v3
        TODO:
        we only consider case dim==3
        we assume no more comment after the num info line
    */
    document.getElementById('inputfile') .addEventListener('change', function() {         
        var fr=new FileReader();         
        fr.readAsText(this.files[0]); 
        fr.onload=function(){ 
            var validLineCount = 0;
            var vertexCount, faceCount, edgeCount;
            var vertices = [];

            var positions = [];
            var normals = [];
            var colors = [];

            const allLines =  fr.result.split(/\r\n|\n/);
            // Reading line by line
            var vertexLineStart = 0;
            for(vertexLineStart; vertexLineStart<allLines.length; vertexLineStart++){
                var line = allLines[vertexLineStart];
                if(line.startsWith("#")){  
                    continue;
                }           
                if(validLineCount==0){
                    // OFF
                    if(!(line == "OFF")){
                        break;
                        console.log("Wrong data format: " + line);
                    }
                    validLineCount += 1;
                }
                else if(validLineCount==1){
                    // count info
                    var infos = line.split(" ");
                    vertexCount = parseInt(infos[0], 10);
                    faceCount = parseInt(infos[1], 10);
                    edgeCount = parseInt(infos[2], 10);
                    validLineCount += 1;
                    console.log(vertexCount);
                    console.log(faceCount);
                    console.log(edgeCount);
                }               
                else if(validLineCount==2){
                    break;
                }
            }
            // using more loops, we can get rid of if branches
            // get list of vertices
            var x,y,z;
            for(var i=0; i<vertexCount; i++){
                var line = allLines[i+vertexLineStart];
                var infos = line.split(" ");
                x = parseInt(infos[0], 10);
                y = parseInt(infos[1], 10);
                z = parseInt(infos[2], 10);
                var v = new THREE.Vector3(x, y, z);
                vertices.push(v);
                positions.push(x,y,z);

                color = new THREE.Color();
                color.setRGB(1,0,0);
                colors.push( color.r, color.g, color.b )
            }

            // get list of faces
            var v1, v2, v3;
            var faceLineStart = vertexLineStart + vertexCount;
            var material = new THREE.MeshNormalMaterial();

            var material2 = new THREE.LineBasicMaterial( { vertexColors: THREE.VertexColors } );

            var pA = new THREE.Vector3();
            var pB = new THREE.Vector3();
            var pC = new THREE.Vector3();
            var cb = new THREE.Vector3();
			var ab = new THREE.Vector3();

            for(var i=0; i<faceCount; i++){
                var line = allLines[i+faceLineStart];
                var infos = line.split(" ");
                v1 = parseInt(infos[1], 10);
                v2 = parseInt(infos[2], 10);
                v3 = parseInt(infos[3], 10);
                
                // method 1
                var Triangle = new THREE.Geometry();
                Triangle.vertices.push(new THREE.Vertex(vertices[v1]));
                Triangle.vertices.push(new THREE.Vertex(vertices[v2]));
                Triangle.vertices.push(new THREE.Vertex(vertices[v3]));
                Triangle.faces.push(new THREE.Face3(0,1,2));
                Triangle.computeFaceNormals();
                // console.log(Triangle);
                var obj = new THREE.Mesh(Triangle, material);
                obj.doubleSided = true;

                // add the obj to the scene
                scene.add(obj);

                // method 2

                // pA = vertices[v1];
                // pB = vertices[v2];
                // pC = vertices[v3];
                // cb.subVectors( pC, pB );
                // ab.subVectors( pA, pB );
                // cb.cross( ab );
                // cb.normalize();

                // var nx = cb.x;
                // var ny = cb.y;
                // var nz = cb.z;    
                // normals.push( nx, ny, nz );
                // normals.push( nx, ny, nz );
                // normals.push( nx, ny, nz );

                // color = new THREE.Color();
                // color.setRGB(1,0,0);
                // colors.push( color.r, color.g, color.b )
                // colors.push( color.r, color.g, color.b )
                // colors.push( color.r, color.g, color.b )
                
            }

            function disposeArray() {
                this.array = null;
            }

            // var geometry = new THREE.BufferGeometry();
            // geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ) );
            // geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ) );

            // geometry.computeBoundingSphere();

            // mesh = new THREE.Line( geometry, material2 );
            // scene.add( mesh );
                
            // var geometry = new THREE.BufferGeometry();
            // geometry.addAttribute( 'position', new THREE.Float32BufferAttribute( positions, 3 ).onUpload( disposeArray ) );
            // geometry.addAttribute( 'normal', new THREE.Float32BufferAttribute( normals, 3 ).onUpload( disposeArray ) );
            // geometry.addAttribute( 'color', new THREE.Float32BufferAttribute( colors, 3 ).onUpload( disposeArray ) );
            // geometry.computeBoundingSphere();

            // mesh = new THREE.Mesh( geometry, material );
            // scene.add( mesh );
            // console.log(scene);

            // var center = geometry.boundingSphere.center;
            // var r = geometry.boundingSphere.radius;
            // console.log(center);
            // console.log(r);

            // camera.position.set(center.x, center.y, center.z+r);	
            // controls.target.set(center.x, center.y, center.z);

            var center = new THREE.Vector3(589230,5213145,1404);
            camera.position.set(center.x, center.y, center.z + 700);
            controls.target.set(center.x, center.y, center.z);

            controls.update();

            
        }
    });

   
                
    function animate() {
        requestAnimationFrame( animate );
        controls.update();
        render();
    }

    function render() {						
        renderer.render( scene, camera );
    }
</script>

</html> 